#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineSensorLeft, sensorLineFollower)
#pragma config(Sensor, in2,    lineSensorMiddle, sensorLineFollower)
#pragma config(Sensor, in3,    lineSensorRight, sensorLineFollower)
#pragma config(Sensor, I2C_1,  moveRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  moveLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  turretEncoder,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  armLeftForwardEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  armRightForwardEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  armRightHandEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_7,  armLeftHandEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           armRightHand,  tmotorVex393_HBridge, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port3,           armLeftHand,   tmotorVex393_MC29, openLoop, encoderPort, I2C_7)
#pragma config(Motor,  port4,           moveRight,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port5,           turret,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           moveLeft,      tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port7,           armsOpen,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armRightForward, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port9,           armLeftForward, tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Name: Zacchary Dempsey-Plante
//Date: 2018-03-27
//Record: 7 Pipes in 1 Round

//Magic Numbers
#define MVU_2_MOVE_VAL (510 / 30.0) //30cm //originally 540
#define DEG_2_TURN_VAL (430 / 90.0) //90 degrees //originally 920 //originally 460 //originally 450
#define DEG_2_TURRET_TURN_VAL (866 / 90.0) //90 degrees
#define ARMS_FORWARD_MOVE_VAL ((1310 / 126.0) - 1) //originally 8.0 //originally 8.5
#define ARMS_OPEN_MOVE_VAL 3.5 //originally 2.5
#define HAND_STATE_MOVE_VAL 2000.0
#define LINE_SENSOR_MIDDLE_DIFF 9 //9cm from front line sensors to middle of bot
#define MAIN_LINE_SPACING 12.5 //Roughly 12.5cm between each line
#define PIPE_DUMP_DIST 70
#define CROSS_MOVE_DIST 30

#define MEASURE_SPEED 64.0

#define NUM_LINES_END_OFFSET 2.5

float weightMultiplier = 1.0;

unsigned const int brakeMultiplier = 1;
unsigned const int brakeMsec = 50;
unsigned const int lineThreshold = (2500 + 135) / 2; //(2450 + 130) / 2 //Average of dark and light reading
unsigned const int lSensorDiff = 1200;

#define RECEIVE_DELAY 25
#define RECEIVE_BITS 9

unsigned char currentState = 0; //0 = start
unsigned char currentSide = 0; //0 = right, 1 = left
signed char currentArmsForwardPos = 0;
signed char currentArmsOpenPos = 0;
unsigned char currentHandsState = 0; //0=vertical, 1=horizontal

bool deliverPipes = true;

unsigned char pipesDone = 0;

void resetMotors()
{
	motor[moveLeft] = 0;
	motor[moveRight] = 0;
	motor[armLeftForward] = 0;
	motor[armRightForward] = 0;
	motor[armLeftHand] = 0;
	motor[armRightHand] = 0;
	motor[armsOpen] = 0;
	motor[turret] = 0;
	/*resetMotorEncoder(moveLeft);
  resetMotorEncoder(moveRight);
	resetMotorEncoder(armLeftForward);
  resetMotorEncoder(armRightForward);
	resetMotorEncoder(armLeftHand);
  resetMotorEncoder(armRightHand);
  resetMotorEncoder(turret);*/
  SensorValue(moveLeftEncoder) = 0;
  SensorValue(moveRightEncoder) = 0;
  SensorValue(armLeftForwardEncoder) = 0;
  SensorValue(armRightForwardEncoder) = 0;
  SensorValue(armLeftHandEncoder) = 0;
  SensorValue(armRightHandEncoder) = 0;
  SensorValue(turretEncoder) = 0;
}
void settleDelay()
{
	wait1Msec(500);
}
signed char brakeSpeed(signed short speed) //Just for convenience
{
	signed short bSpeed = speed * brakeMultiplier;
	return (signed char) (bSpeed <= 126 ? (bSpeed >= -126 ? bSpeed : -126) : 126);
}

void rotTurret(unsigned short speed, signed short degrees) //Positive goes right
{
	unsigned long lastMillis = time1[T1];
	unsigned short lastEncVal = SensorValue(turretEncoder);
	resetMotors();
	if(degrees > 0)
	{
		while(SensorValue(turretEncoder) < degrees * DEG_2_TURRET_TURN_VAL)
		{
			motor[turret] = speed;
			if(time1[T1] > lastMillis + 500)
			{
				//writeDebugStreamLine("Checking turret movement... %d", abs((signed short) SensorValue(turretEncoder) - (signed short) lastEncVal));
				lastMillis = time1[T1];
				if(abs((signed short) SensorValue(turretEncoder) - (signed short) lastEncVal) <= 10)
				{
					//writeDebugStreamLine("Haven't moved much in the last 500 millis. Giving up.");
					break;
				}
				lastEncVal = SensorValue(turretEncoder);
			}
		}
		motor[turret] = 0;
	}
	else
	{
		while(SensorValue(turretEncoder) > degrees * DEG_2_TURRET_TURN_VAL)
		{
			motor[turret] = -speed;
			if(time1[T1] > lastMillis + 500)
			{
				//writeDebugStreamLine("Checking turret movement... %d", abs((signed short) SensorValue(turretEncoder) - (signed short) lastEncVal));
				lastMillis = time1[T1];
				if(abs((signed short) SensorValue(turretEncoder) - (signed short) lastEncVal) <= 10)
				{
					//writeDebugStreamLine("Haven't moved much in the last 500 millis. Giving up.");
					break;
				}
				lastEncVal = SensorValue(turretEncoder);
			}
		}
		motor[turret] = 0;
	}
	resetMotors();
	settleDelay();
}
void setArmsForwardPos(signed char pos)
{
	resetMotors();
	signed short movePos = (pos - currentArmsForwardPos);
	if(movePos > 0)
	{
		bool lArmDone = false;
		bool rArmDone = false;
		while(!lArmDone || !rArmDone)
		{
			if(SensorValue(armLeftForwardEncoder) < movePos * ARMS_FORWARD_MOVE_VAL)
			{
				motor[armLeftForward] = 64;
			}
			else
			{
				lArmDone = true;
				motor[armLeftForward] = 0;
			}
			if(-SensorValue(armRightForwardEncoder) < movePos * ARMS_FORWARD_MOVE_VAL)
			{
				motor[armRightForward] = 64;
			}
			else
			{
				rArmDone = true;
				motor[armRightForward] = 0;
			}
		}
	}
	else if(movePos < 0)
	{
		bool lArmDone = false;
		bool rArmDone = false;
		while(!lArmDone || !rArmDone)
		{
			if(SensorValue(armLeftForwardEncoder) > movePos * ARMS_FORWARD_MOVE_VAL)
			{
				motor[armLeftForward] = -64;
			}
			else
			{
				lArmDone = true;
				motor[armLeftForward] = 0;
			}
			if(-SensorValue(armRightForwardEncoder) > movePos * ARMS_FORWARD_MOVE_VAL)
			{
				motor[armRightForward] = -64;
			}
			else
			{
				rArmDone = true;
				motor[armRightForward] = 0;
			}
		}
	}
	motor[armLeftForward] = 0;
	motor[armRightForward] = 0;
	currentArmsForwardPos = pos;
	resetMotors();
	settleDelay();
}
void setArmsOpenPos(signed char pos)
{
	resetMotors();
	signed short openPos = ((signed short) pos - (signed short) currentArmsOpenPos);
	if(openPos > 0)
	{
		motor[armsOpen] = 32;
		wait1Msec(openPos * ARMS_OPEN_MOVE_VAL);
	}
	else if(openPos < 0)
	{
		motor[armsOpen] = -32;
		wait1Msec(-openPos * ARMS_OPEN_MOVE_VAL);
	}
	motor[armsOpen] = 0;
	currentArmsOpenPos = pos;
	resetMotors();
	settleDelay();
}
void setHandsState(unsigned char state)
{
	resetMotors();
	if(currentHandsState != state)
	{
		if(state == 0)
		{
			bool lHandDone = false;
			bool rHandDone = false;
			while(!lHandDone || !rHandDone)
			{

				if(SensorValue(armLeftHandEncoder) < HAND_STATE_MOVE_VAL)
				{
					motor[armLeftHand] = 64;
				}
				else
				{
					lHandDone = true;
					motor[armLeftHand] = 0;
				}
				if(SensorValue(armRightHandEncoder) < HAND_STATE_MOVE_VAL)
				{
					motor[armRightHand] = 64;
				}
				else
				{
					rHandDone = true;
					motor[armRightHand] = 0;
				}
			}
		}
		else if(state == 1)
		{
			bool lHandDone = false;
			bool rHandDone = false;
			while(!lHandDone || !rHandDone)
			{
				if(SensorValue(armLeftHandEncoder) > -HAND_STATE_MOVE_VAL)
				{
					motor[armLeftHand] = -64;
				}
				else
				{
					lHandDone = true;
					motor[armLeftHand] = 0;
				}
				if(SensorValue(armRightHandEncoder) > -HAND_STATE_MOVE_VAL)
				{
					motor[armRightHand] = -64;
				}
				else
				{
					rHandDone = true;
					motor[armRightHand] = 0;
				}
			}
		}
		motor[armLeftHand] = 0;
		motor[armRightHand] = 0;
	}
	//writeDebugStreamLine("armLeftHandEncoder: %d, armRightHandEncoder: %d", SensorValue(armLeftHandEncoder), SensorValue(armRightHandEncoder));
	currentHandsState = state;
	resetMotors();
	settleDelay();
}

void driveAmnt(unsigned short speed, float amount)
{
	resetMotors();
	if(amount >= 0.0)
	{
		bool lSideDone = false;
		bool rSideDone = false;
		while(!lSideDone || !rSideDone)
		{
			if(-SensorValue(moveLeftEncoder) < round(amount * MVU_2_MOVE_VAL))
			{
				motor[moveLeft] = speed;
			}
			else
			{
				lSideDone = true;
				motor[moveLeft] = 0;
			}
			if(SensorValue(moveRightEncoder) < round(amount * MVU_2_MOVE_VAL))
			{
				motor[moveRight] = speed;
			}
			else
			{
				rSideDone = true;
				motor[moveRight] = 0;
			}
		}
		/*while((-SensorValue(moveLeftEncoder) + SensorValue(moveRightEncoder)) / 2 < round(amount * MVU_2_MOVE_VAL))
		{
			motor[moveLeft] = speed;
			motor[moveRight] = speed;
		}*/
		motor[moveLeft] = brakeSpeed(-speed);
		motor[moveRight] = brakeSpeed(-speed);
		wait1Msec(brakeMsec);
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
	}
	else
	{
		bool lSideDone = false;
		bool rSideDone = false;
		while(!lSideDone || !rSideDone)
		{
			if(-SensorValue(moveLeftEncoder) > round(amount * MVU_2_MOVE_VAL))
			{
				motor[moveLeft] = -speed;
			}
			else
			{
				lSideDone = true;
				motor[moveLeft] = 0;
			}
			if(SensorValue(moveRightEncoder) > round(amount * MVU_2_MOVE_VAL))
			{
				motor[moveRight] = -speed;
			}
			else
			{
				rSideDone = true;
				motor[moveRight] = 0;
			}
		}
		/*while((-SensorValue(moveLeftEncoder) + SensorValue(moveRightEncoder)) / 2 > round(amount * MVU_2_MOVE_VAL))
		{
			motor[moveLeft] = -speed;
			motor[moveRight] = -speed;
		}*/
		motor[moveLeft] = brakeSpeed(speed);
		motor[moveRight] = brakeSpeed(speed);
		wait1Msec(brakeMsec);
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
	}
	resetMotors();
	settleDelay();
}
void turnDegrees(unsigned short speed, float degrees) //clockwise
{
	resetMotors();
	if(degrees >= 0.0)
	{
		bool lSideDone = false;
		bool rSideDone = false;
		while(!lSideDone || !rSideDone)
		{
			if(-SensorValue(moveLeftEncoder) < degrees * DEG_2_TURN_VAL)
			{
				motor[moveLeft] = speed;
			}
			else
			{
				lSideDone = true;
				motor[moveLeft] = 0;
			}
			if(SensorValue(moveRightEncoder) > -degrees * DEG_2_TURN_VAL)
			{
				motor[moveRight] = -speed;
			}
			else
			{
				rSideDone = true;
				motor[moveRight] = 0;
			}
		}
		/*while(getMotorEncoder(moveLeft) - getMotorEncoder(moveRight) < degrees * DEG_2_TURN_VAL)
		{
			motor[moveLeft] = speed;
			motor[moveRight] = -speed;
		}*/
		motor[moveLeft] = brakeSpeed(-speed);
		motor[moveRight] = brakeSpeed(speed);
		wait1Msec(brakeMsec);
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
	}
	else
	{
		bool lSideDone = false;
		bool rSideDone = false;
		while(!lSideDone || !rSideDone)
		{
			if(-SensorValue(moveLeftEncoder) > degrees * DEG_2_TURN_VAL)
			{
				motor[moveLeft] = -speed;
			}
			else
			{
				lSideDone = true;
				motor[moveLeft] = 0;
			}
			if(SensorValue(moveRightEncoder) < -degrees * DEG_2_TURN_VAL)
			{
				motor[moveRight] = speed;
			}
			else
			{
				rSideDone = true;
				motor[moveRight] = 0;
			}
		}
		/*while(getMotorEncoder(moveLeft) - getMotorEncoder(moveRight) > degrees * DEG_2_TURN_VAL)
		{
			motor[moveLeft] = -speed;
			motor[moveRight] = speed;
		}*/
		motor[moveLeft] = brakeSpeed(speed);
		motor[moveRight] = brakeSpeed(-speed);
		wait1Msec(brakeMsec);
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
	}
	resetMotors();
	settleDelay();
}
bool centerOnLine()
{
	unsigned int lSensorLeft = SensorValue(lineSensorLeft);
	unsigned int lSensorMiddle = SensorValue(lineSensorMiddle);
	unsigned int lSensorRight = SensorValue(lineSensorRight);
	if((lSensorMiddle - lSensorLeft) > lSensorDiff && (lSensorMiddle - lSensorRight) > lSensorDiff && lSensorMiddle >= lineThreshold)
	{
		//We're on a line
		//writeDebugStreamLine("On a Line");
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
		return true;
	}
	else if((lSensorLeft - lSensorRight) > lSensorDiff)
	{
		//writeDebugStreamLine("Turning Left");
		motor[moveLeft] = -32;
		motor[moveRight] = 32;
	}
	else if((lSensorRight - lSensorLeft) > lSensorDiff)
	{
		//writeDebugStreamLine("Turning Right");
		motor[moveLeft] = 32;
		motor[moveRight] = -32;
	}
	return false;
}
bool squareOnLine()
{
	unsigned int lSensorLeft = SensorValue(lineSensorLeft);
	unsigned int lSensorMiddle = SensorValue(lineSensorMiddle);
	unsigned int lSensorRight = SensorValue(lineSensorRight);
	if(lSensorLeft >= lineThreshold && lSensorMiddle >= lineThreshold && lSensorRight >= lineThreshold)
	{
		//We're on a line
		//writeDebugStreamLine("On a Line");
		motor[moveLeft] = 0;
		motor[moveRight] = 0;
		return true;
	}
	else if(lSensorLeft >= lineThreshold && lSensorRight < lineThreshold)
	{
		//writeDebugStreamLine("Turning Right");
		motor[moveLeft] = 32;
		motor[moveRight] = 0;
	}
	else if(lSensorRight >= lineThreshold && lSensorLeft < lineThreshold)
	{
		//writeDebugStreamLine("Turning Left");
		motor[moveLeft] = 0;
		motor[moveRight] = 32;
	}
	else
	{
		motor[moveLeft] = -20;
		motor[moveRight] = -20;
	}
	//settleDelay(); //I'm stupid. Why would I add this to a function designed to run as fast as possible?
	return false;
}
void moveNumLines(unsigned char numLines)
{
	resetMotors();
	//Move forward, counting the lines
	unsigned char passedLines = 0;
	while(passedLines < numLines)
	{
		//unsigned int lSensorLeft = SensorValue(lineSensorLeft);
		unsigned int lSensorMiddle = SensorValue(lineSensorMiddle);
		//unsigned int lSensorRight = SensorValue(lineSensorRight);
		motor[moveLeft] = 32;
		motor[moveRight] = 32;
		//if(lSensorLeft >= lineThreshold && lSensorMiddle >= lineThreshold && lSensorRight >= lineThreshold)
		if(lSensorMiddle >= lineThreshold)
		{
			passedLines++;
			writeDebugStreamLine("Just passed Line %d out of %d!", passedLines, numLines);
			//driveAmnt(32, LINE_SENSOR_MIDDLE_DIFF);
			driveAmnt(32, 1);
			while(!squareOnLine()){}
			driveAmnt(32, NUM_LINES_END_OFFSET);
			resetMotors();
		}
	}
	/*motor[moveLeft] = -32;
	motor[moveRight] = -32;
	wait1Msec(brakeMsec);
	motor[moveLeft] = 0;
	motor[moveRight] = 0;*/
	//driveAmnt(32, 6);
	resetMotors();
	settleDelay();
}

task main()
{
	//Quick and dirty pre-run pos values
	currentState = 0;
	currentArmsForwardPos = 0;
	currentArmsOpenPos = 0;
	currentHandsState = 0;
	//Initialization
	resetMotors();
	setArmsForwardPos(0);
	setArmsOpenPos(0);
	setHandsState(0);
	//Delay, then start
	wait1Msec(2000);
	while(true)
	{
		if(currentState == 0)
		{
			//Right Side
			//turnDegrees(64, 90);
			driveAmnt(32, 9);//9.5
			//wait1Msec(1000);
			turnDegrees(38, 89);
			//wait1Msec(5000);
			for(unsigned char i = 0; i < 4; i++)
			{
				moveNumLines(i + 1);
				//settleDelay();
				driveAmnt(32, LINE_SENSOR_MIDDLE_DIFF - NUM_LINES_END_OFFSET);
				if(i <= 0)
				{
					setArmsForwardPos(-32);
					rotTurret(32, -90);
				}
				setArmsOpenPos(126);
				setArmsForwardPos(126);
				setArmsOpenPos(-126);
				setArmsForwardPos(-32);
				driveAmnt(64, -((MAIN_LINE_SPACING * (i + 1)) + PIPE_DUMP_DIST));
				setArmsForwardPos(126);
				setArmsOpenPos(126);
				setArmsForwardPos(0);
				//setArmsOpenPos(0);
				//rotTurret(20, 90);
				pipesDone++;
			}
			//Left Side
			driveAmnt(32, CROSS_MOVE_DIST);
			rotTurret(32, 90);
			motor[armLeftForward] = 32;
			motor[armRightForward] = 32;
			wait1Msec(2000);
			currentArmsForwardPos = 126;
			setArmsForwardPos(0);
			turnDegrees(48, -90);
			driveAmnt(32, 75);
			motor[moveLeft] = 32;
			motor[moveRight] = 32;
			wait1Msec(2000);
			resetMotors();
			driveAmnt(32, -5);
			turnDegrees(48, 89);
			for(unsigned char i = 0; i < 4; i++)
			{
				moveNumLines(i + 1);
				//settleDelay();
				driveAmnt(32, LINE_SENSOR_MIDDLE_DIFF - NUM_LINES_END_OFFSET);
				if(i <= 0)
				{
					setArmsForwardPos(-16);
					rotTurret(32, 90);
				}
				setArmsOpenPos(126);
				setArmsForwardPos(126);
				setArmsOpenPos(-126);
				setArmsForwardPos(20);
				driveAmnt(64, -((MAIN_LINE_SPACING * (i + 1)) + PIPE_DUMP_DIST));
				setArmsForwardPos(126);
				setArmsOpenPos(126);
				setArmsForwardPos(0);
				//setArmsOpenPos(0);
				//rotTurret(20, 90);
				pipesDone++;
			}
			currentState = 1;
		}
		else if(currentState == 1) //Auto reset
		{
			setArmsForwardPos(0);
			setArmsOpenPos(0);
			setHandsState(0);
			currentState = 2;
		}
		else if(currentState == 7) //Testing
		{
			moveNumLines(1);
			while(!squareOnLine()){}
			driveAmnt(32, LINE_SENSOR_MIDDLE_DIFF);
			currentState = 1;
		}
		else if(currentState == 8) //Testing
		{
			rotTurret(32, 90);
			writeDebugStreamLine("Turret: %d", getMotorEncoder(turret));
			wait1Msec(1000);
			rotTurret(32, -90);
			writeDebugStreamLine("Turret: %d", getMotorEncoder(turret));
			/*while(SensorValue(turretEncoder) < 866)
			{
				motor[turret] = 32;
			}
			resetMotors();
			wait1Msec(1000);
			while(SensorValue(turretEncoder) > -866)
			{
				motor[turret] = -32;
			}
			resetMotors();*/
			currentState = 1;
		}
		else if(currentState == 9) //Testing
		{
			/*while((-SensorValue(moveLeftEncoder) + SensorValue(moveRightEncoder)) / 2 < 203)
			{
				motor[moveLeft] = 64;
				motor[moveRight] = 64;
			}*/
			motor[moveLeft] = 64;
			motor[moveRight] = 64;
			wait1Msec(500);
			motor[moveLeft] = 0;
			motor[moveRight] = 0;
			wait1Msec(1000);
			currentState = 1;
		}
		else if(currentState == 10) //Testing
		{
			setArmsForwardPos(-16);
			wait1Msec(1000);
			setArmsForwardPos(126);
			wait1Msec(1000);
			currentState = 1;
		}
		else if(currentState == 11) //Testing
		{
			moveNumLines(2);
			wait1Msec(1000);
			driveAmnt(64, -30);
			moveNumLines(3);
			wait1Msec(1000);
			driveAmnt(64, -30);
			currentState = 1;
		}
		else if(currentState == 12) //Testing
		{
			driveAmnt(32, 30);
			currentState = 1;
		}
		else if(currentState == 13) //Testing
		{
			turnDegrees(48, 90);
			wait1Msec(1000);
			turnDegrees(48, -90);
			currentState = 1;
		}
		else if(currentState == 14) //Testing
		{
			driveAmnt(32, 10);
			wait1Msec(1000);
			driveAmnt(32, -10);
			currentState = 1;
		}
		else if(currentState == 15) //Testing
		{
			rotTurret(32, -90);
			wait1Msec(500);
			rotTurret(32, 90);
			currentState = 1;
		}
		else
		{
			//motor[moveLeft] = 64;
			resetMotors();
		}
	}
}
